/**
* Button custom element.
*/
JQX('jqx-button', class Button extends JQX.ContentElement {
    // Button's properties.
    static get properties() {
        return {
            'value': {
                type: 'string'
            },
            'name': {
                type: 'string'
            },
            'type': {
                type: 'string'
            },
            'clickMode': {
                allowedValues: ['hover', 'press', 'release', 'pressAndRelease'],
                type: 'string',
                value: 'release'
            }
        };
    }

    scopedStyle() {
        const baseStyle = super.scopedStyle();
        const elementStyle = `
                :host {
                    display: inline-block;
                }
                :host-context(.jqx-button-large) #button {
                    padding: 10px 16px;
                    font-size: 18px;
                    line-height: 1.3333333;
                }
                :host-context(.jqx-button-small) #button {
                    padding: 5px 10px;
                    font-size: 12px;
                    line-height: 1.5;
                }
                :host-context(.jqx-button-very-small) #button {
                    padding: 1px 5px;
                    font-size: 12px;
                    line-height: 1.5;
                }
                :host-context(.jqx-button) #button {
                    padding: 6px 12px;
                    margin-bottom: 0;
                    font-size: 14px;
                    font-weight: 400;
                    line-height: 1.42857143;
                }
                #button {
                    padding: 1px 2px 1px 2px;
                    text-align: center;
                    vertical-align: central;
                    color: var(--jqx-color);
                    border: 1px solid var(--jqx-border-color);
                    background: var(--jqx-background-color, blue);
                    cursor: pointer;
                }
                #button:focus {
                    color: var(--jqx-focus-color);
                    border-color: var(--jqx-focus-border-color);
                    background-color: var(--jqx-focus-background-color);
                }
                #button.hover {
                  color: var(--jqx-hover-color);
                  border-color: var(--jqx-hover-border-color);
                  background-color: var(--jqx-hover-background-color);
                  transition: background-color 100ms linear;
                }
                #button:active,
                #button.active {
                    color: var(--jqx-active-color);
                    border-color: var(--jqx-active-border-color);
                    background-color: var(--jqx-active-background-color);
                    transition: background-color 100ms linear;
                }
                #button[disabled] {
                    color: var(--jqx-disabled-color);
                    border-color: var(--jqx-disabled-border-color);
                    background-color: var(--jqx-disabled-background-color);
                    cursor: default;
                }
            `;

        return baseStyle + elementStyle;
    }
    /** Button's template. */
    template() {
        return '<button class=\'jqx-button\' inner-h-t-m-l=\'[[innerHTML]]\' id=\'button\' type=\'[[type]]\' name=\'[[name]]\' value=\'[[value]]\' disabled=\'[[disabled]]\' role=\'button\'></button>';
    }

    static get listeners() {
        return {
            'button.down': '_mouseDownHandler',
            'button.mouseenter': '_mouseEnterHandler',
            'button.mouseleave': '_mouseLeaveHandler',
            'button.touchend': '_touchEndHandler',
            'button.click': '_clickHandler'
        };
    }

    _clickHandler(event) {
        const that = this;

        if ((that.clickMode !== 'release' && that.clickMode !== 'pressAndRelease') || that.readonly) {
            event.preventDefault();
            event.stopPropagation();
        }
    }

    _mouseDownHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        event.originalEvent.stopPropagation();

        if (that.theme.indexOf('material') > -1) {
            JQX.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY);
        }

        if ((that.clickMode === 'press' || that.clickMode === 'pressAndRelease') && !that.readonly) {
            const buttons = ('buttons' in event) ? event.buttons : event.which;

            that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
        }
    }

    _mouseEnterHandler(event) {
        const that = this;

        if (that.readonly) {
            return;
        }

        that.$button.addClass('hover');

        if (that.clickMode === 'hover') {
            const buttons = ('buttons' in event) ? event.buttons : event.which;

            that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
        }
    }

    _touchEndHandler() {
        const that = this;

        setTimeout(function () {
            that.$button.removeClass('hover');
        }, 300);
    }

    _mouseLeaveHandler() {
        const that = this;

        that.$button.removeClass('hover');
    }

    /**
* Called when a property is changed.
*/
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        if (propertyName === 'disabled') {
            that._setFocusable();

            if (that.$button) {
                that.$button.removeClass('hover');
            }

            if (that instanceof JQX.RepeatButton) {
                that._stopRepeat();
            }
        }
        else if (propertyName === 'unfocusable') {
            that._setFocusable();
        }
    }

    /**
     * Sets tab index 
     */
    _setFocusable() {
        const that = this;

        const target = that.$.button ? that.$.button : that;

        if (that.disabled || that.unfocusable) {
            target.removeAttribute('tabindex');
            target.tabIndex = -1;
            return;
        }

        target.tabIndex = that.tabIndex > 0 ? that.tabIndex : 0;
    }

    ready() {
        const that = this;

        super.ready();

        that._setFocusable();
    }
});

/**
* Repeat Button.
*/
JQX('jqx-repeat-button', class RepeatButton extends JQX.Button {
    // button's properties.
    static get properties() {
        return {
            'delay': {
                value: 50,
                type: 'number'
            },
            'initialDelay': {
                value: 150,
                type: 'number'
            }
        };
    }

    static get listeners() {
        return {
            'button.mousedown': '_startRepeat',
            'button.mouseenter': '_updateInBoundsFlag',
            'button.mouseleave': '_updateInBoundsFlag',
            'document.mouseup': '_stopRepeat'
        };
    }

    _clickHandler(event) {
        const that = this;

        if (that.clickMode !== 'release' || that.preventDefaultClick || that.readonly || that.disabled) {
            event.preventDefault();
            event.stopPropagation();
            that.preventDefaultClick = false;
        }
    }

    _updateInBoundsFlag(event) {
        const that = this;

        that._isPointerInBounds = true;

        if (event.type === 'mouseleave') {
            that._isPointerInBounds = false;
        }
        const buttons = ('buttons' in event) ? event.buttons : event.which;
        if (buttons !== 1) {
            that._stopRepeat();
        }
    }

    _startRepeat(event) {
        const that = this;
        if (!that._initialTimer && !that.readonly) {
            that._initialTimer = setTimeout(function () {
                that._repeatTimer = setInterval(() => {
                    if (that._isPointerInBounds) {
                        const buttons = ('buttons' in event) ? event.buttons : event.which;

                        that.$.fireEvent('click', { buttons: buttons, clientX: event.clientX, clientY: event.clientY, pageX: event.pageX, pageY: event.pageY, screenX: event.screenX, screenY: event.screenY });
                        that.preventDefaultClick = true;
                    }
                }, that.delay);
            }, that.initialDelay);
        }
    }

    _stopRepeat() {
        const that = this;

        if (that.readonly) {
            return;
        }

        if (that._repeatTimer) {
            clearInterval(that._repeatTimer);
            that._repeatTimer = null;
        }

        if (that._initialTimer) {
            clearTimeout(that._initialTimer);
            that._initialTimer = null;
        }
    }
});

/**
* Toggle Button.
*/
JQX('jqx-toggle-button', class ToggleButton extends JQX.Button {
    // Toggle Button's properties.
    static get properties() {
        return {
            'checked': {
                value: false,
                type: 'boolean?'
            },
            'falseContent': {
                value: '',
                reflectToAttribute: false,
                type: 'string'
            },
            'indeterminateContent': {
                value: '',
                reflectToAttribute: false,
                type: 'string'
            },
            'indeterminate': {
                value: false,
                type: 'boolean'
            },
            'trueContent': {
                value: '',
                reflectToAttribute: false,
                type: 'string'
            },
            'indeterminateTemplate': {
                value: null,
                type: 'any'
            },
            'trueTemplate': {
                value: null,
                type: 'any'
            },
            'falseTemplate': {
                value: null,
                type: 'any'
            }
        };
    }

    /**
    * Toggle Button's event listeners.
    */
    static get listeners() {
        return {
            'keydown': '_keyHandler',
            'keyup': '_keyHandler',
            'dragstart': '_dragStartHandler',
            'button.click': '_buttonClickHandler',
            'button.mouseenter': '_buttonMouseEnterHandler',
            'document.up': '_documentUpHandler'
        };
    }

    /** Called when the element is ready. Used for one-time configuration of the ToggleButton. */
    ready() {
        super.ready();
    }

    /**
     * Overrides the inherited "click" handler of the inner button element.
     */
    _buttonClickHandler() { }

    /**
     * Changes the check state on hover.
     */
    _buttonMouseEnterHandler() {
        const that = this;

        if ((that.disabled) || (that.readonly) || (that.clickMode !== 'hover')) {
            return;
        }

        that._changeCheckState('pointer');
        that.focus();
        that._updateHidenInputNameAndValue();
    }

    /** Changes the check state wneh widget container is clicked. */
    _documentUpHandler() {
        const that = this;

        if (!that._pressed) {
            return;
        }

        that._pressed = false;

        if ((that.disabled) || (that.readonly) || (that.clickMode === 'press')) {
            return;
        }

        that._changeCheckState('pointer');
        that.focus();
        that._updateHidenInputNameAndValue();
    }

    _mouseDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        if (that.theme.indexOf('material') > -1) {
            JQX.Utilities.Animation.Ripple.animate(that, event.pageX, event.pageY);
        }

        that._pressed = true;

        if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') {
            that._changeCheckState('pointer');
            that.$.fireEvent('click');
            that._updateHidenInputNameAndValue();
        }

        if (that.clickMode === 'press') {
            event.preventDefault();
            event.stopPropagation();
        }
    }

    _dragStartHandler(event) {
        event.preventDefault();
    }

    /** Changes the check state when spacebar is pressed. */
    _keyHandler(event) {
        const that = this;

        if ((that.disabled !== true) && !that.readonly && (event.keyCode === 32)) {
            if (event.type === 'keydown') {
                event.preventDefault();
                return;
            }

            that._changeCheckState('keyboard');
            that._updateHidenInputNameAndValue();
        }
    }

    /** Changes the check state. */
    _changeCheckState(changeType) {
        const that = this;

        let oldValue = null;

        if (that.checked === null) {
            that.checked = true;
        }
        else {
            oldValue = that.checked;
            that.checked = !that.checked;
        }

        that._handleTextSelection();

        that.$.fireEvent('change', { 'value': that.checked, 'oldValue': oldValue, changeType: changeType });
    }

    _handleTextSelection() {
        const that = this;

        that.$.addClass('jqx-unselectable');

        if (that.timer) {
            clearTimeout(that.timer);
        }

        that.timer = setTimeout(() => that.$.removeClass('jqx-unselectable'), 500);
    }

    /**
    * Called when a property is changed.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);
        const that = this;

        if (propertyName === 'checked') {
            that.$.fireEvent('change', { 'value': newValue, 'oldValue': oldValue, changeType: 'api' });
        }

        switch (propertyName) {
            case 'trueTemplate':
                that._handleTemplate(true);
                break;
            case 'falseTemplate':
                that._handleTemplate(false);
                break;
            case 'indeterminateTemplate':
                that._handleTemplate();
                break;
        }
    }

    _htmlBindOnInitialization() {
        const that = this;

        that._bindContentProperty('trueContent', 'jqx-true-content');
        that._bindContentProperty('falseContent', 'jqx-false-content');
        that._bindContentProperty('indeterminateContent', 'jqx-indeterminate-content');
    }

    _bindContentProperty(propertyName, className) {
        const that = this;

        if (!that.$[propertyName + 'Container']) {
            return;
        }

        let testElement = document.createElement('div');

        testElement.innerHTML = that.innerHTML;

        let elements = testElement.getElementsByClassName(className),
            element;

        if (elements.length > 0) {
            for (let i = 0; i < elements.length; i++) {
                element = elements[i];
            }
        }

        if (that[propertyName] === '') {
            that[propertyName] = element === undefined ? '' : element.outerHTML;
        }

        that.$[propertyName + 'Container'].innerHTML = that[propertyName];
    }

    _updateContentProperties() {
        const that = this;

        update('trueContent');
        update('falseContent');
        update('indeterminateContent');

        function update(property) {
            if (that.$[property + 'Container']) {
                that[property] = that.$[property + 'Container'].innerHTML;
            }
        }
    }

    _updateHidenInputValue() {
        const that = this;

        if (!that.$.hiddenInput) {
            return;
        }

        let inputValue;

        if (that.checked === null) {
            inputValue = 'null';
        }
        else if (that.checked === false) {
            inputValue = 'off';
        }
        else {
            inputValue = that.value || 'on';
        }

        that.$.hiddenInput.setAttribute('value', inputValue);
    }

    _updateHidenInputName() {
        const that = this;

        if (!that.$.hiddenInput) {
            return;
        }

        let inputName = that.checked === false ? '' : that.name || '';

        that.$.hiddenInput.setAttribute('name', inputName);
    }

    _updateHidenInputNameAndValue() {
        const that = this;

        that._updateHidenInputName();
        that._updateHidenInputValue();
    }

    /**
     * Apply a template to true/false/indeterminate states of the elements.
     */
    _handleTemplate(state, oldValue) {
        const that = this;
        let template, templateTarget, value;


        if (state === true) {
            template = that.trueTemplate;
            templateTarget = that.$.trueContentContainer;
            value = that.trueContent;
        }
        else if (state === false) {
            template = that.falseTemplate;
            templateTarget = that.$.falseContentContainer;
            value = that.falseContent;
        }
        else {
            template = that.indeterminateTemplate;
            templateTarget = that.$.indeterminateContentContainer;
            value = that.indeterminateContent;
        }

        if (oldValue) {
            templateTarget.innerHTML = value ? value : '';
        }

        if (template === null || !template) {
            return;
        }

        if (typeof template === 'function') {
            template(templateTarget, { value: value });
            return;
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        template = document.getElementById(template);
        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'template' }));
            return;
        }

        const content = template.content,
            childrenCount = content.childNodes.length,
            regex = /{{\w+}}/g;
        let bindingString,
            bindingDetails = [];

        for (let i = 0; i < childrenCount; i++) {
            bindingString = regex.exec(content.childNodes[i].innerHTML);
            while (bindingString) {
                bindingDetails.push({ childNodeIndex: i, bindingString: bindingString[0] });
                bindingString = regex.exec(content.childNodes[i].innerHTML);
            }
        }

        const bindingsCount = bindingDetails.length;
        let clone = document.importNode(template.content, true),
            bindingHolderElement,
            bindingStringsCount;

        for (let b = 0; b < bindingsCount; b++) {
            bindingHolderElement = clone.childNodes[bindingDetails[b].childNodeIndex];
            bindingStringsCount = bindingDetails.length;
            for (let i = 0; i < bindingStringsCount; i++) {
                bindingHolderElement.innerHTML = bindingHolderElement.innerHTML.replace(bindingDetails[b].bindingString, value);
            }
        }

        templateTarget.innerHTML = '';
        for (let i = 0; i < clone.childNodes.length; i++) {
            if (clone.childNodes[i].outerHTML) {
                templateTarget.innerHTML += clone.childNodes[i].outerHTML;
            }
        }
    }
});

