/**
* RadioButton custom element.
*/
JQX('jqx-radio-button', class RadioButton extends JQX.ToggleButton {
    // RadioButton's properties.
    static get properties() {
        return {
            'groupName': {
                value: '',
                type: 'string'
            },
            'enableContainerClick': {
                value: false,
                type: 'boolean'
            }
        };
    }

    /** RadioButton's Html template. */
    template() {
        return `<div  id='container' class='jqx-container'>
                 <div id='radioButtonAnimation' class ='jqx-animation'></div>
                 <span id='radioButtonInput' class ='jqx-input'></span>
                 <span id='radioButtonLabel' inner-h-t-m-l='[[innerHTML]]' class ='jqx-label'><content></content></span>
                 <input id='hiddenInput' class ='jqx-hidden-input' type='hidden'>
               </div>`;
    }

    static get listeners() {
        return {
            'down': '_downHandler',
            'document.up': '_documentUpHandler',
            'mouseenter': '_mouseenterHandler'
        };
    }

    /** Called when the element is ready. Used for one-time configuration of the Checkbox. */
    ready() {
        const that = this;

        super.ready();
        that._updateHidenInputNameAndValue();
    }

    /**
     * Radio button down handler.
     */
    _downHandler(event) {
        const that = this,
            target = event.originalEvent.target;

        if (that.disabled || that.readonly) {
            return;
        }

        if (!that.enableContainerClick && target !== that.$.radioButtonInput) {
            return;
        }

        if (that.theme.indexOf('material') > -1) {
            const rect = that.$.radioButtonInput.getBoundingClientRect(),
                windowScrollX = window.scrollX || window.pageXOffset,
                windowScrollY = window.scrollY || window.pageYOffset;

            JQX.Utilities.Animation.Ripple.animate(that.$.radioButtonInput, rect.left + rect.width / 2 + windowScrollX, rect.top + rect.height / 2 + windowScrollY);
        }

        if (that._preventAction) {
            that._preventAction = false;
            return;
        }

        if (that.clickMode === 'release' || that.clickMode === 'pressAndRelease') {
            that._pressed = true;
        }

        if (that.clickMode === 'press' || that.clickMode === 'pressAndRelease') {
            if (that.clickMode === 'pressAndRelease') {
                if (that.groupName === '') {
                    that._checkedBeforeChange = that.parentNode.querySelector('jqx-radio-button[checked]');
                }
                else {
                    that._checkedBeforeChange = document.querySelector('jqx-radio-button[group-name="' + that.groupName + '"][checked]');
                }
            }

            that._handleMouseInteraction();
        }
    }

    /**
     * Radio button mouseenter handler.
     */
    _mouseenterHandler() {
        const that = this;

        if (that.clickMode === 'hover' && !that.disabled && !that.readonly) {
            that._handleMouseInteraction();
        }
    }

    /**
     * Document up handler.
     */
    _documentUpHandler(event) {
        const that = this;

        if (!that._pressed || that.disabled || that.readonly || (event.target === that.$.radioButtonLabel && !that.enableContainerClick)) {
            return;
        }

        if (that.clickMode === 'release') {
            that._handleMouseInteraction();
        }
        else {
            // clickMode: 'pressAndRelease'
            if (that._checkedBeforeChange === null) {
                that.$.fireEvent('change', { 'value': false, 'oldValue': true, 'changeType': 'pointer' });
                that.checked = false;
            }
            else {
                that._checkedBeforeChange._changeCheckState('pointer');
            }

            that.focus();
            that._updateHidenInputNameAndValue();
        }

        that._pressed = false;
    }

    /**
     * Handles interaction with the mouse.
     */
    _handleMouseInteraction() {
        const that = this;

        that._handleTextSelection();

        that._changeCheckState('pointer');
        that.focus();
        that._updateHidenInputNameAndValue();
    }

    /** Changes the check state. */
    _changeCheckState(changeType) {
        const that = this;

        let radioButtonsGroup = document.querySelectorAll('jqx-radio-button[group-name="' + that.groupName + '"]');

        if ((that.checked === true && changeType === 'api') || (that.checked === false)) {
            if (radioButtonsGroup.length > 0) {
                that._changeCheckStateInGroup(radioButtonsGroup, changeType);
            }
            else {
                let parent = that.parentNode;
                radioButtonsGroup = parent.querySelectorAll('jqx-radio-button:not([group-name])');
                that._changeCheckStateInGroup(radioButtonsGroup, changeType);
            }
        }
    }

    /** Changes the check states in group of radio buttons. */
    _changeCheckStateInGroup(elements, changeType) {
        const that = this;

        for (let i = 0; i < elements.length; i++) {
            elements[i]._isUpdating = true;

            if (elements[i] === that) {
                that.checked = true;
                that.$.fireEvent('change', { 'value': true, 'oldValue': false, 'changeType': changeType });
            }
            else if (elements[i].checked) {
                elements[i].checked = false;
            }

            elements[i]._isUpdating = false;
        }
    }

    /**
    * Updates the radio button/radio group when checked property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {

        const that = this;

        switch (propertyName) {
            case 'value':
                that._updateHidenInputNameAndValue();
                break;
            case 'checked':
                if (!that._isUpdating) {
                    that._changeCheckState('api');
                }
                that._updateHidenInputNameAndValue();
                break;
            case 'name':
                that._updateHidenInputName();
                break;
            default:
                super.propertyChangedHandler(propertyName, oldValue, newValue);
                break;
        }
    }
});
