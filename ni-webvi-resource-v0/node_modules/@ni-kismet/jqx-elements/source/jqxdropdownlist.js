/**
* DropDownLst custom element.
*/
JQX('jqx-drop-down-list', class DropDownList extends JQX.ContentElement {

    /** 
    * DropDownList's properties 
    */
    static get properties() {
        return {
            'dataSource': {
                value: null,
                type: 'any',
                reflectToAttribute: false
            },
            'displayLoadingIndicator': {
                value: false,
                type: 'boolean'
            },
            'displayMember': {
                value: '',
                type: 'string'
            },
            'dropDownAppendTo': {
                value: null,
                type: 'any'
            },
            'dropDownButtonPosition': {
                allowedValues: ['left', 'right', 'top', 'bottom'],
                value: 'right',
                type: 'string'
            },
            'dropDownHeight': {
                value: '',
                type: 'string'
            },
            'dropDownOpenMode': {
                allowedValues: ['none', 'default', 'dropDownButton', 'auto'],
                value: 'default',
                type: 'string'
            },
            'dropDownPlaceholder': {
                value: 'No Items',
                type: 'string'
            },
            'dropDownPosition': {
                allowedValues: ['auto', 'top', 'bottom', 'overlay-top', 'overlay-center', 'overlay-bottom', 'center-bottom', 'center-top'],
                value: 'auto',
                type: 'string'
            },
            'dropDownWidth': {
                value: '',
                type: 'string'
            },
            'filterable': {
                value: false,
                type: 'boolean'
            },
            'filterInputPlaceholder': {
                value: '',
                type: 'string'
            },
            'filterMode': {
                value: 'startsWithIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'],
                type: 'string'
            },
            'grouped': {
                value: false,
                type: 'boolean'
            },
            'groupMember': {
                value: '',
                type: 'string'
            },
            'hint': {
                value: '',
                type: 'string'
            },
            'incrementalSearchDelay': {
                value: 700,
                type: 'number?'
            },
            'incrementalSearchMode': {
                value: 'startsWithIgnoreCase',
                allowedValues: ['contains', 'containsIgnoreCase', 'doesNotContain', 'doesNotContainIgnoreCase', 'equals', 'equalsIgnoreCase', 'startsWith', 'startsWithIgnoreCase', 'endsWith', 'endsWithIgnoreCase'],
                type: 'string'
            },
            'itemTemplate': {
                value: null,
                type: 'any'
            },
            'itemHeight': {
                value: null,
                type: 'number?'
            },
            'label': {
                value: '',
                type: 'string'
            },
            'loadingIndicatorPlaceholder': {
                value: 'Loading...',
                type: 'string'
            },
            'loadingIndicatorPosition': {
                value: 'center',
                allowedValues: ['bottom', 'center', 'top'],
                type: 'string'
            },
            'messages': {
                extend: true,
                value: {
                    'en': {
                        'invalidNode': '{{elementType}}: Invalid parameter "{{node}}" when calling {{method}}.'
                    }
                },
                type: 'object'
            },
            'name': {
                value: '',
                type: 'string'
            },
            'opened': {
                value: false,
                type: 'boolean'
            },
            'placeholder': {
                value: '',
                type: 'string'
            },
            'resizeMode': {
                value: 'none',
                allowedValues: ['none', 'horizontal', 'vertical', 'both'],
                type: 'string'
            },
            'resizeIndicator': {
                value: false,
                type: 'boolean'
            },
            'selectionDisplayMode': {
                value: 'plain',
                allowedValues: ['plain', 'placeholder', 'tokens'],
                type: 'string'
            },
            'selectionMode': {
                value: 'one',
                allowedValues: ['none', 'oneOrManyExtended', 'zeroOrMany', 'oneOrMany', 'zeroOrOne', 'one', 'checkBox', 'radioButton'],
                type: 'string'
            },
            'selectedIndexes': {
                value: [],
                type: 'array'
            },
            'selectedValues': {
                value: [],
                type: 'array'
            },
            'sorted': {
                value: false,
                type: 'boolean'
            },
            'tokenTemplate': {
                value: null,
                type: 'any'
            },
            'valueMember': {
                value: '',
                type: 'string'
            },
            'virtualized': {
                value: false,
                type: 'boolean'
            }
        }
    }

    /**
    * DropDownList's event listeners.
    */
    static get listeners() {
        return {
            'actionButton.down': '_buttonsDownHandler',
            'actionButton.mouseenter': '_buttonsMouseEventsHandler',
            'actionButton.mouseleave': '_buttonsMouseEventsHandler',
            'document.selectstart': '_selectStartHandler',
            'document.dragstart': '_dragStartHandler',
            'document.down': '_documentDownHandler',
            'document.up': '_documentUpHandler',
            'document.move': '_documentMoveHandler',
            'dropDownButton.down': '_buttonsDownHandler',
            'dropDownButton.mouseenter': '_buttonsMouseEventsHandler',
            'dropDownButton.mouseleave': '_buttonsMouseEventsHandler',
            'keydown': '_keyDownHandler',
            'keyup': '_keyUpHandler',
            'blur': '_focusEventHandler',
            'dropDownButton.blur': '_focusEventHandler',
            'listBox.change': '_listBoxChangeHandler',
            'listBox.keydown': '_listBoxKeyDownHandler',
            'listBox.bindingComplete': '_bindingCompleteHandler',
            'mouseenter': '_mouseEnterHandler',
            'mouseleave': '_mouseLeaveHandler',
            'resize': '_resizeHandler',
            'styleChanged': '_styleChangedHandler'
        };
    }

    /**
    * DropDownList's HTML template.
    */
    template() {
        return `<div id="container">
                    <span class="jqx-label" id="label">[[label]]</span>
                    <div id="content" class="jqx-content">
                        <span id="actionButton" class="jqx-action-button"></span>
                        <span id="dropDownButton" class="jqx-drop-down-button">
                            <span id="arrow"></span>
                        </span>
                        <div id="dropDownContainer" class="jqx-drop-down jqx-visibility-hidden">
                            <jqx-list-box id="listBox" unfocusable
                                    data-source="[[dataSource]]"
                                    disabled="[[disabled]]"
                                    display-loading-indicator="[[displayLoadingIndicator]]"
                                    display-member="[[displayMember]]"
                                    filterable="[[filterable]]"
                                    filter-mode="[[filterMode]]"
                                    filter-input-placeholder="[[filterInputPlaceholder]]"
                                    grouped="[[grouped]]"
                                    group-member="[[groupMember]]"
                                    item-height="[[itemHeight]]"
                                    item-template="[[itemTemplate]]"
                                    incremental-search-delay="[[incrementalSearchDelay]]"
                                    incremental-search-mode="[[incrementalSearchMode]]"
                                    loading-indicator-placeholder="[[loadingIndicatorPlaceholder]]"
                                    loading-indicator-position="[[loadingIndicatorPosition]]"
                                    name="[[name]]"
                                    placeholder="[[dropDownPlaceholder]]"
                                    readonly="[[readonly]]"
                                    selected-indexes="{{selectedIndexes}}"
                                    selection-mode="[[selectionMode]]"
                                    selected-values="{{selectedValues}}"
                                    sorted="[[sorted]]"
                                    theme="[[theme]]"
                                    value-member="[[valueMember]]"
                                    virtualized="[[virtualized]]">
                                <content></content>
                            </jqx-list-box>
                            <div id="resizeBar" class="jqx-drop-down-resize-bar">
                                <div></div>
                            </div>
                         </div>
                    </div>
                    <span class="jqx-hint" id="hint">[[hint]]</span>
                </div>`;
    }

    /**
    * Updates the DropDownList when a property is changed.
    * @param {string} propertyName The name of the property.
    * @param {number/string} oldValue The previously entered value. Max, min and value are of type Number. The rest are of type String.
    * @param {number/string} newValue The new entered value. Max, min and value are of type Number. The rest are of type String.
    */
    propertyChangedHandler(propertyName, oldValue, newValue) {
        super.propertyChangedHandler(propertyName, oldValue, newValue);

        const that = this;

        switch (propertyName) {
            case 'disabled':
                that._setFocusable();
                that.close();
                break;
            case 'dataSource':
            case 'displayMember':
                //when selectedValues is 0 and displayMember is changed set actionButton text to default.
                if (that.$.actionButton) {
                    that.$.actionButton.innerHTML = that.placeholder;
                }

                //Check the new listBox size
                that._setDropDownSize();
                that._checkBrowserBounds('vertically');

                if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
                    that._rePositionListBox();
                }

                that._checkBrowserBounds('horizontally');

                break;
            case 'dropDownAppendTo':
                that._setElementParent(newValue);
                break;
            case 'dropDownOpenMode':
                that._setFocusable();

                //Close the dropDownList without throwing events.
                that.$dropDownContainer.addClass('jqx-visibility-hidden');
                that.$.dropDownButton.removeAttribute('selected');
                break;
            case 'dropDownPosition':
                that.$.dropDownContainer.removeAttribute(that._dropDownListPosition);
                that._setDropDownPosition(newValue);
                that._rePositionListBox();
                break;
            case 'dropDownWidth':
            case 'dropDownHeight':
                that._setDropDownSize();
                break;
            case 'opened':
                if (that.disabled || that.readonly) {
                    return;
                }

                newValue ? that.open() : that.close();
                break;
            case 'placeholder':
                that._applySelection();
                break;
            case 'readonly':
                that.close();
                break;
            case 'resizeIndicator':
                if (newValue) {
                    that.$.dropDownContainer.setAttribute('resize-indicator', '');
                }
                else {
                    that.$.dropDownContainer.removeAttribute('resize-indicator');
                }

                break;
            case 'resizeMode':
                that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode);
                break;
            case 'selectedValues':
            case 'selectedIndexes':
                if (newValue.length === 0) {
                    that.$.actionButton.innerHTML = that.placeholder;
                }

                break;
            case 'selectionDisplayMode':
                that._applySelection();
                break;
            case 'tokenTemplate':
                that._tokenTemplate = that._validateTemplate(that.tokenTemplate);
                that._applySelection();
                break;
            case 'unfocusable':
                that._setFocusable();
                break;
        }
    }

    /**
    * Appends a jqx-list-item to the end of the DropDownList.
    */
    appendChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.appendChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'appendChild', node: 'node' }));
            return
        }

        that.$.listBox.appendChild(node);
    }

    /**
    * Called when the element is attached from the DOM.
    */
    attached() {
        const that = this;

        super.attached();

        if (!that.$.listBox) {
            return;
        }

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            that._setElementParent(that.dropDownAppendTo);
            that._setDropDownSize();
        }

        if (that.dropDownPosition === 'auto') {
            that._checkBrowserBounds();
        }
    }

    /**
     * Called when the element is detached from the DOM.
     */
    detached() {
        const that = this;

        super.detached();

        if (!that.$.dropDownContainer) {
            return;
        }

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0 && that.$.dropDownContainer.parentElement) {
            that.$.dropDownContainer.parentElement.removeChild(that.$.dropDownContainer);
        }
    }

    /**
    * Removes all items from DOM.
    */
    clearItems() {
        const that = this;

        that.$.listBox.clearItems();
        that.$.actionButton.innerHTML = that.placeholder;
    }

    /**
    * Unselects all items.
    */
    clearSelection() {
        const that = this;

        that.$.listBox.clearSelection();
        that.$.actionButton.innerHTML = that.placeholder;
    }

    /**
    * Hides the drop down list.
    */
    close() {
        const that = this;

        if (that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
            return;
        }

        const isOpeningEventPrevented = that.$.fireEvent('closing').defaultPrevented;

        if (isOpeningEventPrevented) {
            return;
        }

        that.$dropDownContainer.addClass('jqx-visibility-hidden');
        that.$.fireEvent('close');

        if (that.$.dropDownButton) {
            that.$.dropDownButton.removeAttribute('selected');
        }

        that.opened = false;
        that._preventDropDownClose = false;
    }

    /**
    * Creates a clone of the element.
    */
    cloneNode() {
        const that = this;
        let clone = HTMLElement.prototype.cloneNode.apply(that, Array.prototype.slice.call(arguments, 0, 1));

        //Set only those properties that have reflectToAttribute set to false.
        clone.dataSource = that.dataSource;
        return clone;
    }

    /**
    * Ensures the desired item is visible by scrolling to it.
    */
    ensureVisible(item) {
        this.$.listBox.ensureVisible(item);
    }

    /**
    * Returns a JQX.ListItem element if it's value is matched.
    */
    getItem(value) {
        return this.$.listBox.getItem(value);
    }

    /**
    * Returns an array with the items from the list.
    */
    get items() {
        if (!this.$) {
            return;
        }

        return this.$.listBox.items;
    }

    /**
    * Inserts an item at a specified position.
    * @param {number} index The index at which a new item will be inserted.
    * @param {string/object/array} item Describes the properties of the item that will be inserted. 
     If string is passed, it will be processed as the label for the new item. 
     If an object is passed, it must contain valid properties for the item, e.g. { label, value, group, disabled }.
     If an array is passed, multiple items will be inserted in the list with the coressponding settings.
    */
    insert(index, item) {
        const that = this;

        that.$.listBox.insert(index, item);

        //Add the item to the ActionButton if the item is selected.
        that._applySelection()
    }

    /**
    * Inserts a jqx-list-item to the DropDownList at a certain position.
    */
    insertBefore(newNode, referenceNode) {
        const that = this;

        if (!that.isCompleted) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.insertBefore.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!newNode || !referenceNode) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'insertBefore', node: 'newNode/referenceNode' }));
            return;
        }

        that.$.listBox.insertBefore(newNode, referenceNode);
    }

    /**
    * Shows the drop down List.
    */
    open() {
        const that = this,
            getFirstFocusableItem = function () {
                for (let i = 0; i < that.items.length; i++) {
                    if (!that.items[i].disabled) {
                        return that.items[i];
                    }
                }
            };

        if (that.disabled) {
            return;
        }

        if (!that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
            return;
        }

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            const rect = that.getBoundingClientRect();

            // handles the case, when the dropdown is opened, while it is still part of the dropdownlist's tree. 
            if (that.$.container.contains(that.$.dropDownContainer)) {
                let iterations = 0;
                const interval = setInterval(function () {
                    const rect = that.getBoundingClientRect();

                    iterations++;

                    if (rect.top === that._positionTop && iterations < 10) {
                        return;
                    }

                    that.open();
                    clearInterval(interval);
                    that._positionTop = rect.top;
                }, 100);

                return;
            }
            else if (rect.top !== that._positionTop) {
                that._positionTop = rect.top;
            }
        }

        const isOpeningEventPrevented = that.$.fireEvent('opening').defaultPrevented;

        if (isOpeningEventPrevented) {
            return;
        }

        that._checkBrowserBounds('vertically');

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            that._rePositionListBox();
        }

        that._checkBrowserBounds('horizontally');

        that.$dropDownContainer.removeClass('jqx-visibility-hidden');
        that.$.fireEvent('open');

        if (that.$.dropDownButton) {
            if (that.dropDownOpenMode === 'dropDownButton') {
                that.$.dropDownButton.setAttribute('selected', '');
            }
            else {
                that.$.dropDownButton.removeAttribute('selected');
            }
        }

        if (!that.$.listBox._focusedItem || (that.$.listBox._focusedItem && !that.$.listBox._focusedItem.focused)) {
            if (that.selectedIndexes.length > 0) {
                that._focus(that.items[that.selectedIndexes[0]]);
            }
            else {
                that._focus(getFirstFocusableItem);
            }
        }

        if (that.$.input) {
            that.$.input.focus();
        }

        that.opened = true;
    }

    /**
    * DropDownList ready method.
    */
    ready() {
        super.ready();

        const that = this;

        if (that.$.dropDownContainer) {
            that._setDropDownPosition(that.dropDownPosition);
            that._calculateDropDownSize();
            that.$.dropDownContainer.setAttribute('resize-mode', that.resizeMode);

            if (that.resizeIndicator) {
                that.$.dropDownContainer.setAttribute('resize-indicator', '');
            }
        }

        if (that.opened) {
            that.open();
        }

        //Used for the scroll handling
        that._positionTop = that.getBoundingClientRect().top;

        that._createElement();
    }

    /**
    * Removes an item from the list box.
    * @param {number} index The index at which a new item will be inserted.
    */
    remove(index) {
        const that = this;

        that.$.listBox.remove(index);

        //Remove the item from the ActionButton if its present.
        that._applySelection();
    }

    /**
    * Removes a jqx-list-item frop the DropDownList.
    */
    removeChild(node) {
        const that = this;

        if (!that.isCompleted || node instanceof HTMLElement && node.classList.contains('jqx-resize-trigger-container')) {
            const args = Array.prototype.slice.call(arguments, 2);
            return HTMLElement.prototype.removeChild.apply(that, args.concat(Array.prototype.slice.call(arguments)));
        }

        if (!node || !(node instanceof JQX.ListItem)) {
            that.error(that.localize('invalidNode', { elementType: that.nodeName.toLowerCase(), method: 'removeChild', node: 'node' }));
            return
        }

        that.$.listBox.removeChild(node);
    }

    /**
    * Selects an item by its HTML Element or Value.
    */
    select(item) {
        this.$.listBox.select(item);
    }

    /**
    * Sets tab index 
    */
    _setFocusable() {
        const that = this;

        if (that.disabled || that.unfocusable) {
            that.removeAttribute('tabindex');
            that.$.actionButton.removeAttribute('tabindex');
            that.$.dropDownButton.removeAttribute('tabindex');
            return;
        }

        let index = that.tabIndex > 0 ? that.tabIndex : 0;

        if (that.dropDownOpenMode === 'dropDownButton') {
            that.removeAttribute('tabindex');
            that.$.actionButton.setAttribute('tabindex', index);
            that.$.dropDownButton.setAttribute('tabindex', index);
        }
        else {
            that.$.actionButton.removeAttribute('tabindex');
            that.$.dropDownButton.removeAttribute('tabindex');
            that.tabIndex = index;
        }
    }

    /**
    * Checks for missing modules.
    */
    static get requires() {
        return {
            'JQX.ListBox': 'jqxlistbox.js'
        }
    }

    /**
    * Unselects an item by its HTML Element or Value.
    */
    unselect(item) {
        this.$.listBox.unselect(item);
    }

    /**
    * Updates an item from the list.
    * @param {number} index The index at which a new item will be inserted.
    * @param {string/object} settings The settings that will be applied to the item that will be updated.
      If a string is passed, it will be considered as the new label for the item.
      If an object is passed, it will should describe valid properties for the item, e.g. { label, value, group, disabled}.
    */
    update(index, details) {
        const that = this;

        that.$.listBox.update(index, details);
        that._applySelection();
    }

    /**
    * Sets the selection mode for the DropDownList.
    */
    _applySelection() {
        const that = this;

        function createToken() {
            let icon;
            const fragment = document.createDocumentFragment();

            if (that.selectionDisplayMode === 'plain' && (that.selectionMode === 'one' || that.selectionMode === 'zeroOrOne' || that.selectionMode === 'radioButton')) {
                icon = '';
            }
            else {
                if (that.selectionDisplayMode === 'tokens') {
                    if (that.selectedIndexes.length === 1 && (['oneOrManyExtended', 'oneOrMany', 'one', 'radioButton'].indexOf(that.selectionMode) > -1)) {
                        icon = '';
                    }
                    else {
                        icon = '&#10006';
                    }
                }
                else {
                    icon = that.selectedIndexes.length === 1 ? '' : ',';
                }
            }

            that.selectedIndexes.map(index => {
                fragment.appendChild(that._applyTokenTemplate(that.$.listBox._items[index].label, icon));
            });

            return fragment;
        }

        if (that.selectionDisplayMode === 'placeholder' || that.selectedIndexes.length === 0) {
            that.$.actionButton.innerHTML = that.placeholder;
            return;
        }

        if (!that.$.listBox._items || that.$.listBox._items.length === 0) {
            return;
        }

        that.$.actionButton.innerHTML = '';
        that.$.actionButton.appendChild(createToken());
    }

    /**
    * Applies a template to the tokens
    */
    _applyTokenTemplate(label, icon) {
        const that = this;
        const element = document.createElement('span'),
            token = function () {
                return '<span class=\'jqx-drop-down-list-selection-label\'>' + label +
                    '</span><span class=\'jqx-drop-down-list-unselect-button\'>' + icon + '</span>';
            };

        element.classList.add('jqx-token');

        if (that._tokenTemplate) {
            let content = document.importNode(that._tokenTemplate.content, true);
            const childrenCount = content.childNodes.length,
                regex = /{{\w+}}/g;
            let bindingString;

            for (let i = 0; i < childrenCount; i++) {
                bindingString = regex.exec(content.childNodes[i].innerHTML);

                if (bindingString) {
                    content.childNodes[i].innerHTML = content.childNodes[i].innerHTML.replace(bindingString[0], token());
                }

                if (content.childNodes[i].outerHTML) {
                    element.innerHTML += content.childNodes[i].outerHTML;
                }
            }
        }
        else if (typeof that.tokenTemplate === 'function') {
            that.tokenTemplate(element, { label: label, iconSeparator: icon });
        }
        else {
            element.innerHTML = token();
        }

        return element;
    }

    /**
     * BindingComplete event Handler. When the dataSource or size of listBox is changed.
     */
    _bindingCompleteHandler() {
        const that = this;

        if (!that.$.listBox) {
            return;
        }

        that._setDropDownSize();
        that._checkBrowserBounds();
    }

    /**
    * Action/DropDown button mouse down event handler.
    */
    _buttonsDownHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        if (that.theme.indexOf('material') > -1) {
            JQX.Utilities.Animation.Ripple.animate(event.target, event.pageX, event.pageY);
        }

        that._preventsSelectStart = true;

        if (that.dropDownOpenMode === 'dropDownButton' && event.target === that.$.actionButton) {
            that.$actionButton.addClass('active');
        }

        //Used to handle closing after blur event is thrown
        if (that.opened) {
            that._preventDropDownClose = true;
        }
    }

    /**
    * DropDownList container mouse enter/leave events handler.
    */
    _buttonsMouseEventsHandler(event) {
        const that = this;

        if (that.disabled) {
            return;
        }

        event.type === 'mouseenter' ? event.target.$.addClass('hovered') : event.target.$.removeClass('hovered');
    }

    /**
    * Calculates the dropDownSize and creates an object with the sizes
    */
    _calculateDropDownSize() {
        const that = this;

        that._dropDownSize = {};

        const computedStyle = window.getComputedStyle(that.$.dropDownContainer);
        const topBorder = parseFloat(computedStyle.getPropertyValue('border-top-width').trim()),
            bottomBorder = parseFloat(computedStyle.getPropertyValue('border-bottom-width').trim()),
            topPaddinng = parseFloat(computedStyle.getPropertyValue('padding-top').trim()),
            bottomPaddinng = parseFloat(computedStyle.getPropertyValue('padding-bottom').trim());

        if (JQX.Utilities.Core.CSSVariablesSupport()) {
            that._dropDownSize.width = computedStyle.getPropertyValue('--jqx-drop-down-element-width').trim();
            that._dropDownSize.height = computedStyle.getPropertyValue('--jqx-drop-down-element-height').trim();
        }

        if (!that._dropDownSize.width || that._dropDownSize.width.indexOf('initial') > -1) {
            that._dropDownSize.width = that.offsetWidth;
        }

        if (!that._dropDownSize.height) {
            that._dropDownSize.height = 'auto';
        }

        that._dropDownSize.minHeight = parseFloat(computedStyle.getPropertyValue('min-height').trim());
        that._dropDownSize.maxHeight = parseFloat(computedStyle.getPropertyValue('max-height').trim());
        that._dropDownSize.borderWidth = (isNaN(topBorder) ? 0 : topBorder) + (isNaN(bottomBorder) ? 0 : bottomBorder);
        that._dropDownSize.paddingWidth = (isNaN(topPaddinng) ? 0 : topPaddinng) + (isNaN(bottomPaddinng) ? 0 : bottomPaddinng);
    }

    /**
     * Check browser bounds Vertically
     */
    _checkBrowserBoundsVertically(dropDownListCoordinates) {
        const that = this;

        if (!dropDownListCoordinates) {
            dropDownListCoordinates = that.getBoundingClientRect();
        }

        if (that._dropDownListPosition) {
            that.$.dropDownContainer.removeAttribute(that._dropDownListPosition);
            that.$.dropDownButton.removeAttribute(that._dropDownListPosition);
        }

        if (document.documentElement.clientHeight - Math.abs(dropDownListCoordinates.top + dropDownListCoordinates.height + that.$.dropDownContainer.offsetHeight) >= 0) {
            that._dropDownListPosition = 'bottom';
        }
        else if (dropDownListCoordinates.top - that.$.dropDownContainer.offsetHeight >= 0) {
            that._dropDownListPosition = 'top';
        }
        else {
            //if there's no space above or under, place over
            that._dropDownListPosition = 'overlay-bottom';
            // Solution: Maybe reduce the height ?
        }

        that.$.dropDownButton.setAttribute(that._dropDownListPosition, '');
        that.$.dropDownContainer.setAttribute(that._dropDownListPosition, '');
    }

    /**
     * Check browser bounds Horizontally
     */
    _checkBrowserBoundsHorizontally() {
        const that = this;
        let isParentChanged,
            vScrollBar = 0;

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            isParentChanged = true;

            //if vertical scrollbar is visible
            if (window.innerWidth !== document.documentElement.clientWidth) {
                vScrollBar = window.innerWidth - document.documentElement.clientWidth;
            }
        }
        else {
            that.$.dropDownContainer.style.left = '';
        }

        let currentOffsetLeft = that.getBoundingClientRect().left;

        //Left side check - Not Tested
        if (currentOffsetLeft < 0) {
            that.$.dropDownContainer.style.left = (isParentChanged ? 0 : Math.abs(currentOffsetLeft)) + 'px';
            currentOffsetLeft = parseFloat(that.$.dropDownContainer.style.left);
        }

        //Right side check
        if (currentOffsetLeft + that.$.dropDownContainer.offsetWidth > document.documentElement.clientWidth) {
            const newOffset = currentOffsetLeft - Math.abs(document.documentElement.clientWidth - currentOffsetLeft - that.$.dropDownContainer.offsetWidth);

            that.$.dropDownContainer.style.left = (isParentChanged ? newOffset : newOffset - currentOffsetLeft) + 'px';

            //if vertical scrollbar has become hidden
            if (window.innerWidth === document.documentElement.clientWidth) {
                that.$.dropDownContainer.style.left = (parseFloat(that.$.dropDownContainer.style.left) + vScrollBar) + 'px';
            }

            //if the dropDownList is in another container different from the listBox's
            if (isParentChanged && window.innerHeight === document.documentElement.clientHeight) {
                that._rePositionListBox(true);
            }
        }

        //TODO: What if there's no space to the left nor the right ?
    }

    /**
     * Checks window bounds and repositions the listbox popup
     */
    _checkBrowserBounds(direction) {
        const that = this;

        if (that.disabled || that.dropDownPosition !== 'auto') {
            return;
        }

        switch (direction) {
            case 'vertically':
                that._checkBrowserBoundsVertically();
                break;
            case 'horizontally':
                that._checkBrowserBoundsHorizontally();
                break;
            default:
                that._checkBrowserBoundsVertically();
                that._checkBrowserBoundsHorizontally();
                break;
        }
    }

    /**
    * Initializes the element.
    */
    _createElement() {
        const that = this;

        that._tokenTemplate = that._validateTemplate(that.tokenTemplate);

        //Set properties.
        that._applySelection();
        that._setDropDownSize();
        that._setFocusable();

        //Flag indicator for the ripple effect. Used to append the ripple to that specific element, not his firstElementChild like it's done usually.
        //Used in class Ripple, method animate() in jqxelement.
        that.$.arrow.noRipple = true;

        if (!that.disabled && that.dropDownPosition === 'auto') {
            // eslint-disable-next-line
            PositionDetection.handleAutoPositioning.call(this, that._scrollHandler, 200, () => { return that.dropDownPosition !== 'auto'; });
        }
    }

    /**
     * Handles the scrolling
     */
    _scrollHandler() {
        const that = this;

        if (!that.parentElement) {
            return;
        }

        const rect = that.getBoundingClientRect();

        if (rect.top === that._positionTop) {
            return;
        }

        that._checkBrowserBoundsVertically(rect);

        if (that.opened && that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            that._rePositionListBox();
        }

        that._positionTop = rect.top;
    }

    /**
    * Document mouse down event handler.
    */
    _documentDownHandler(event) {
        const that = this;

        if (that.disabled || that.readonly) {
            return;
        }

        const listItem = event.originalEvent.target.closest('jqx-list-item'),
            scrollBar = event.originalEvent.target.closest('jqx-scroll-bar');

        if (that.theme.indexOf('material') > -1 && listItem) {
            JQX.Utilities.Animation.Ripple.animate(listItem, event.pageX, event.pageY);
        }

        that._isListBoxThumbDragged = event.target !== document && event.target.classList.contains('jqx-thumb')
            && event.target.ownerElement.ownerElement === that.$.listBox;

        if (listItem || event.originalEvent.target === that.$.listBox.$.filterInput || event.originalEvent.target.closest('.jqx-token') ||
            (scrollBar && (scrollBar === that.$.listBox.$.verticalScrollBar || scrollBar === that.$.listBox.$.horizontalScrollBar))) {
            that._preventDropDownClose = true;
        }

        if (event.originalEvent.target !== that.$.resizeBar || that.resizeMode === 'none') {
            return;
        }

        if (!that._resizeDetails) {
            that._resizeDetails = {};
        }

        const computedStyle = that.$.dropDownContainer.getBoundingClientRect();

        that._resizeDetails.started = true;
        that._resizeDetails.x = event.pageX;
        that._resizeDetails.y = event.pageY;
        that._resizeDetails.width = that.$.dropDownContainer.offsetWidth;
        that._resizeDetails.height = that.$.dropDownContainer.offsetHeight;
        that._resizeDetails.offsetXL = event.clientX - computedStyle.left;
        that._resizeDetails.offsetXR = computedStyle.left + that.$.dropDownContainer.offsetWidth - event.clientX;
        that._resizeDetails.offsetY = computedStyle.top + that.$.dropDownContainer.offsetHeight - event.clientY;
        that._resizeDetails.offsetYtop = event.clientY - computedStyle.top;
        that._preventDropDownClose = true;
    }


    /**
     * Document Move Event handler
     * @param {any} event
     */
    _documentMoveHandler(event) {
        const that = this;

        if (!that._resizeDetails || (that._resizeDetails && !that._resizeDetails.started)) {
            return;
        }

        that.setAttribute('resizing', '');

        if (!that._resizeDetails.resizeEventFired) {
            that.$.fireEvent('resizeStart', {
                'position': { left: event.pageX, top: event.pageY }
            });

            that._resizeDetails.resizeEventFired = true;
        }

        const doc = document.documentElement,
            computedStyle = that.$.dropDownContainer.getBoundingClientRect(),
            dropDownStyle = that.getBoundingClientRect(),
            direction = that.$.dropDownContainer.hasAttribute('top') ? 'top' : 'bottom';
        let size;

        function verticalResize() {
            size = event.pageY - that._resizeDetails.y;

            if (direction === 'bottom') {
                //6 is the margin of document.body, we don't want scrollbars to be shown
                that._resizeDetails.height = Math.min(doc.clientHeight - computedStyle.top - 6,
                    Math.max(0, that._resizeDetails.height + size));

                that._resizeDetails.y = Math.max(computedStyle.top + doc.scrollTop - that._resizeDetails.offsetY,
                    Math.min(doc.clientHeight + doc.scrollTop - that._resizeDetails.offsetY * 1.5, event.pageY));
            }
            else {
                that._resizeDetails.height = Math.min(that._dropDownSize.maxHeight, Math.max(0, Math.min(that.offsetTop, that._resizeDetails.height - size)));

                size = Math.max(0, that.$.dropDownContainer.offsetTop + (computedStyle.height - Math.max(that._dropDownSize.minHeight, that._resizeDetails.height)));

                that.$.dropDownContainer.style.top = that.dropDownAppendTo && that.dropDownAppendTo.length > 0 ? size + 'px' : '';

                const minYCondition = dropDownStyle.top + doc.scrollTop + that._resizeDetails.offsetYtop;

                that._resizeDetails.y = Math.max(that._resizeDetails.offsetYtop,
                    Math.min(minYCondition, Math.max(minYCondition - that._dropDownSize.maxHeight, event.pageY)));
            }

            that.$.dropDownContainer.style.height = that._resizeDetails.height + 'px';
        }

        function horizontalResize() {
            //Resize only from corner
            //if (that._resizeDetails.offsetXR > 20) {
            //    return;
            //}

            size = event.pageX - that._resizeDetails.x;

            //6 is the margin of document.body, we don't want scrollbars to be shown
            that._resizeDetails.width = Math.min(doc.clientWidth - computedStyle.left - 6,
                Math.max(0, that._resizeDetails.width + size));

            that.$.dropDownContainer.style.width = that._resizeDetails.width + 'px';

            that._resizeDetails.x = Math.max(computedStyle.left + doc.scrollLeft - that._resizeDetails.offsetXR,
                Math.min(doc.clientWidth + doc.scrollLeft - that._resizeDetails.offsetXR * 1.5, event.pageX));
        }

        switch (that.resizeMode) {
            case 'vertical':
                verticalResize();
                break;
            case 'horizontal':
                horizontalResize();
                break;
            case 'both':
                horizontalResize();
                verticalResize();
                break;
        }
    }

    /**
    * Document Up handler.
    */
    _documentUpHandler(event) {
        const that = this;

        that.$actionButton.removeClass('active');

        if (that._resizeDetails && that._resizeDetails.started) {
            that._resizeDetails.started = that._resizeDetails.resizeEventFired = false;
            that.removeAttribute('resizing');
            that._preventDropDownClose = false;
            that.focus();

            that.$.fireEvent('resizeEnd', {
                'position': { left: event.pageX, top: event.pageY }
            });
            return;
        }

        if (that.disabled || that._isListBoxThumbDragged || that.readonly) {
            return;
        }

        let target = event.originalEvent.target;

        that._preventsSelectStart = false;

        if (typeof (target) === 'undefined' || target === that.$.resizeBar) {
            return;
        }

        if (that.selectionDisplayMode === 'tokens' && target.classList.contains('jqx-drop-down-list-selection-label') && target.closest('jqx-drop-down-list') === that) {
            if (that.dropDownOpenMode !== 'none') {
                that.open();
            }

            let item = that.$.listBox._items.filter(item => item.label.toString() === target.textContent)[0];

            //Scroll to that item and focus it.
            that.$.listBox._scrollView.scrollTop = item.offsetTop;
            that._focus(item);
            return;
        }

        if (target.classList.contains('jqx-drop-down-list-unselect-button') && target.closest('jqx-drop-down-list') === that) {
            if (that.selectedIndexes.length === 1 && ['zeroOrMany', 'zeroOrOne', 'checkBox'].indexOf(that.selectionMode) < 0) {
                return;
            }

            that.unselect(that.$.listBox._items.filter(item => item.label.toString() === target.previousElementSibling.textContent)[0]);
            return;
        }

        if (target.closest('.jqx-action-button') === that.$.actionButton || target.closest('.jqx-drop-down-button') === that.$.dropDownButton) {
            if (that.dropDownOpenMode === 'dropDownButton' && target === that.$.actionButton) {
                that.close();
                return;
            }

            //Open/Close the dropDownList
            that.$dropDownContainer.hasClass('jqx-visibility-hidden') && that.dropDownOpenMode !== 'none' ? that.open() : that.close();
            return;
        }

        target = that._getUpEventTarget(target);

        if (target === undefined) {
            return;
        }

        if (target !== 'listBox' && target !== 'item' || target === 'item' && that.selectionMode !== 'checkBox' && that.selectionMode.indexOf('Many') < 0) {
            that.close();
        }
    }

    /**
    * DragStarted Event Handler
    * @param {any} event
    */
    _dragStartHandler(event) {
        const that = this;

        if (that._resizeDetails && that._resizeDetails.started) {
            event.preventDefault();
        }
    }

    /**
    * Focuses an item. Accepts a JQX.ListItem element or a string, representing the value of an item.
    */
    _focus(item) {
        this.$.listBox._focus(item);
    }

    /**
     * Element/DropDownButton blur event handler
     * @param {any} event
     */
    _focusEventHandler() {
        const that = this;

        if (that.nodeName && that.nodeName === 'JQX-DROP-DOWN-LIST' && !that._preventDropDownClose) {
            that.close();
        }
    }

    /**
     * Gets the target of a document up event.
     */
    _getUpEventTarget(target) {
        const that = this;

        while (target) {
            if (target instanceof JQX.ListItem && target.ownerListBox === that.$.listBox) {
                if (target.unselectable || target.disabled) {
                    return;
                }

                target = 'item';
                break;
            }
            else if (target === that.$.listBox) {
                target = 'listBox';
                break;
            }

            target = target.parentElement;
        }

        return target;
    }

    /**
    * DropDown keydown event handler.
    */
    _keyDownHandler(event) {
        const that = this;

        if (event.target === that.$.listBox.$.filterInput) {
            return;
        }

        switch (event.key) {
            case 'Enter':
            case ' ':
                event.target.$.addClass('active');
                event.preventDefault();

                if (event.target !== that.$.actionButton) {
                    that._keyPressed = true;

                    if (that.opened) {
                        if (that.$.listBox._focusedItem) {
                            that.select(that.$.listBox._focusedItem);
                        }

                        if (event.key === 'Enter' && ['one', 'none'].indexOf(that.selectionMode) < 0) {
                            that.close();
                        }
                    }
                    else if (!that.opened && !that.readonly && that.dropDownOpenMode !== 'none') {
                        that.open();
                    }
                }

                break;
            case 'End':
            case 'Home':
            case 'PageUp':
            case 'PageDown':
            case 'ArrowUp':
            case 'ArrowDown':
                if (that.readonly) {
                    return;
                }

                if (event.altKey) {
                    that._keyPressed = false;
                    that.$dropDownContainer.hasClass('jqx-visibility-hidden') ? that.open() : that.close();
                    return;
                }

                event.preventDefault();
                that.$.listBox._handleKeyStrokes(event.key);
                break;
            case 'Escape':
                that.close();
                break;
            default:
                if (that.readonly) {
                    return;
                }

                if (that.selectionMode === 'oneOrManyExtended') {
                    that.$.listBox._keysPressed[event.key] = true;
                }

                that.$.listBox._applyIncrementalSearch(event.key);
                break;
        }
    }

    /**
    * DropDown key up event handler.
    */
    _keyUpHandler(event) {
        const that = this;

        if (event.target === that.$.listBox.$.filterInput) {
            return;
        }

        if (event.key === 'Enter' || event.key === ' ') {
            event.target.$.removeClass('active');

            if (!that.$dropDownContainer.hasClass('jqx-visibility-hidden')) {
                that._keyPressed = false;
                //that.$.listBox.focus();
            }
        }

        if (that.selectionMode === 'oneOrManyExtended') {
            that.$.listBox._keysPressed[event.key] = false;
        }
    }

    /**
    * DropDownList Change event handler.
    */
    _listBoxChangeHandler(event) {
        const that = this;

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            that.$.fireEvent('change', event.detail);
        }

        that._applySelection(that.selectionMode, event.detail);
    }

    /**
    * DropDownList key down handler.
    */
    _listBoxKeyDownHandler(event) {
        const that = this;

        if (event.key === 'Enter') {
            that.close();
            that.dropDownOpenMode === 'dropDownButton' ? that.$.dropDownButton.focus() : that.focus();
            event.stopPropagation();
        }

        if (event.key === 'Escape') {
            that.close();
            return;
        }
    }

    ///**
    // * Used to check the browser bounds when listBox resizes.
    // */
    //_listBoxResizeHandler() {
    //    const that = this;

    //    that._checkBrowserBounds();
    //}

    /**
    * Element container mouse enter event handler.
    */
    _mouseEnterHandler() {
        const that = this;

        that.$.addClass('hovered');

        if (that.tagName === 'JQX-DROP-DOWN-LIST' && that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) {
            that.open();
        }
    }

    /**
    * Element container mouse leave event handler.
    */
    _mouseLeaveHandler() {
        const that = this;

        that.$.removeClass('hovered');

        if (that.dropDownOpenMode === 'auto' && !that.disabled && !that.readonly) {
            that.close();
        }
    }

    /**
    * Calculates the new position of the popup afer it's parent has been changed.
    */
    _rePositionListBox(vertically) {
        const that = this;

        if (!that.dropDownAppendTo || that.dropDownAppendTo.length === 0) {
            that.$.dropDownContainer.style.left = '';
            that.$.dropDownContainer.style.top = '';
            ['font-size', 'font-family', 'font-style', 'font-weight'].map(styleName => that.$.dropDownContainer.style[styleName] = '');
            that.$dropDownContainer.removeClass('jqx-drop-down-repositioned');
            return;
        }

        that.$dropDownContainer.addClass('jqx-drop-down-repositioned');

        const coordinates = that.getBoundingClientRect();
        let top = coordinates.top,
            left = 0;

        //Remove old position
        that.$.dropDownContainer.removeAttribute(that._dropDownListPosition);

        switch (that._dropDownListPosition) {
            case 'bottom':
                top += that.$.container.offsetHeight - 1; // 1 is the min border-width. Doesn't matter if it's bigger.
                that._dropDownListPosition = 'bottom';
                break;
            case 'center-bottom':
                top += that.$.container.offsetHeight - 1;
                left += that.offsetWidth - that.$.dropDownContainer.offsetWidth / 2;
                that._dropDownListPosition = 'center-bottom';
                break;
            case 'center-top':
                top -= that.$.dropDownContainer.offsetHeight - 1;
                left += that.offsetWidth - that.$.dropDownContainer.offsetWidth / 2;
                that._dropDownListPosition = 'center-top';
                break;
            case 'top':
                top -= that.$.dropDownContainer.offsetHeight - 1;
                that._dropDownListPosition = 'top';
                break;
            case 'overlay-bottom':
                that._dropDownListPosition = 'overlay-bottom';
                break;
            case 'overlay-center':
                top -= that.$.dropDownContainer.offsetHeight / 2 - that.offsetHeight / 2;
                that._dropDownListPosition = 'overlay-center';
                break;
            case 'overlay-top':
                top -= that.$.dropDownContainer.offsetHeight - that.offsetHeight;
                that._dropDownListPosition = 'overlay-top';
                break;
        }

        that.$.dropDownContainer.style.top = top + window.pageYOffset + 'px';

        //Apply the new position
        that.$.dropDownContainer.setAttribute(that._dropDownListPosition, '');

        if (vertically) {
            return;
        }

        that.$.dropDownContainer.style.left = left + coordinates.left + window.pageXOffset + 'px';
    }

    /**
     * Resize handler - recalculate the size of the popup if the element is initialized with a different size.
     */
    _resizeHandler() {
        const that = this;

        if (that.resizeMode === 'none') {
            that._calculateDropDownSize();
            that._setDropDownSize();
        }
    }

    /**
    * Document select start event handler.
    */
    _selectStartHandler(event) {

        if (this._preventsSelectStart) {
            event.preventDefault();
        }
    }

    /**
     * Set the drop down position property.
     * @param {any} value
     */
    _setDropDownPosition(value) {
        const that = this;

        if (that._dropDownListPosition) {
            that.$.dropDownButton.removeAttribute(that._dropDownListPosition);
        }

        if (value === 'auto') {
            that._checkBrowserBounds();
        }
        else {
            that._dropDownListPosition = value;
        }

        that.$.dropDownButton.setAttribute(that._dropDownListPosition, '');
        that.$.dropDownContainer.setAttribute(that._dropDownListPosition, '');
    }

    /**
    * Set DropDown Size.
    */
    _setDropDownSize() {
        const that = this;

        if (!that._dropDownSize) {
            that._calculateDropDownSize();
        }

        if (that.dropDownWidth) {
            if (that.dropDownWidth !== 'auto') {
                that.$.dropDownContainer.style.width = (that.dropDownWidth === 'initial' ? that.offsetWidth : parseFloat(that.dropDownWidth)) + 'px';
            }
            else {
                that.$.dropDownContainer.style.width = 'auto';
            }
        }
        else {
            that.$.dropDownContainer.style.width = that._dropDownSize.width === 'auto' ? 'auto' : (parseFloat(that._dropDownSize.width) || 0) + 'px';
        }

        if (that.dropDownHeight && that.dropDownHeight !== 'auto') {
            that.$.dropDownContainer.style.height = parseFloat(that.dropDownHeight) + 'px';
        }
        else {
            if (that._dropDownSize.height === 'auto') {
                that.$.dropDownContainer.style.height = '';

                const bottomOffset = 2;

                let dropDownHeight = bottomOffset;

                if (that.$.listBox.items.length > 0) {
                    that.$.listBox.items.map(item => dropDownHeight += item.offsetHeight);
                }

                dropDownHeight = dropDownHeight + that._dropDownSize.paddingWidth + that._dropDownSize.borderWidth;
                that.$.dropDownContainer.style.height = dropDownHeight + 'px';
            }
            else {
                that.$.dropDownContainer.style.height = that._dropDownSize.height;
            }
        }

        that.$.listBox._refreshLayout();
    }

    /**
    * Handles the dropDownAppendTo property.
    */
    _setElementParent(id) {
        const that = this;

        that.$.hasClass('animation') ? that.$dropDownContainer.addClass('animation') : that.$dropDownContainer.removeClass('animation');

        if (that.theme !== '') {
            that.$dropDownContainer.addClass(that.theme);
        }

        if (!id || id.length === 0) {
            that.$.container.appendChild(that.$.dropDownContainer);
        }
        else if (id === 'body') {
            document.body.appendChild(that.$.dropDownContainer);

            if (that.detachedChildren.indexOf(that.$.dropDownContainer) === -1) {
                that.detachedChildren.push(that.$.dropDownContainer);
            }
        }
        else {
            let holder;

            if (id instanceof HTMLElement) {
                holder = id;
            }
            else if (typeof (id) === 'string') {
                holder = document.getElementById(id);
            }

            if (!holder) {
                return;
            }

            holder.appendChild(that.$.dropDownContainer);
        }

        that._rePositionListBox();
    }

    /**
     * Style changed event handler
     * @param {any} event
     */
    _styleChangedHandler(event) {
        const that = this;

        if (that.dropDownAppendTo && that.dropDownAppendTo.length > 0) {
            const styleProperties = event.detail.styleProperties,
                fontProperties = ['font-size', 'font-family', 'font-style', 'font-weight'];

            for (let s = 0; s < fontProperties.length; s++) {
                if (styleProperties[fontProperties[s]]) {
                    that.$.dropDownContainer.style[fontProperties[s]] = styleProperties[fontProperties[s]].value;
                }
            }

        }

        if (that._dropDownSize.height === 'auto') {
            that._setDropDownSize();
        }
    }

    /**
    * Checks for HTMLTemplate support and returns it's content.
    */
    _validateTemplate(template) {
        const that = this;

        if (!template) {
            return;
        }

        if (typeof template === 'function') {
            return;
        }

        if (!('content' in document.createElement('template'))) {
            that.error(that.localize('htmlTemplateNotSuported', { elementType: that.nodeName.toLowerCase() }));
            return;
        }

        if (!(template instanceof HTMLTemplateElement)) {
            template = document.getElementById(template);
        }

        if (template === null || !('content' in template)) {
            that.error(that.localize('invalidTemplate', { elementType: that.nodeName.toLowerCase(), property: 'tokenTemplate' }));
            return;
        }

        return template;
    }
});

class PositionDetection {
    /**
     * Checks Element's position inside the document
     */
    static handleAutoPositioning(handler, delay, conditionCallback) {
        const that = this;

        // eslint-disable-next-line
        const requestAnimFrame = (() => { return window.requestAnimationFrame })();
        let start = Date.now(), animationFrame;

        function loop() {
            animationFrame = requestAnimFrame(loop);

            //Cancel condition.
            if (conditionCallback()) {
                cancelAnimationFrame(animationFrame);
            }

            const current = Date.now();

            if (current - start >= delay) {
                handler.call(that);
                start = Date.now();
            }
        }

        return animationFrame = requestAnimFrame(loop);
    }
}