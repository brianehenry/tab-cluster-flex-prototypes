// Draw class
JQX.Utilities.Assign('Draw', class Draw {
    constructor(host) {
        const that = this;

        that.host = host;
        that.renderEngine = '';

        that.refresh();

        const functions = [
            'clear',
            'removeElement',
            'attr',
            'getAttr',
            'line',
            'circle',
            'rect',
            'path',
            'pieslice',
            'pieSlicePath',
            'text',
            'measureText'
        ];

        for (let i in functions) {
            that._addFn(JQX.Utilities.Draw.prototype, functions[i]);
        }
    }

    _addFn(target, name) {
        if (target[name])
            return;

        target[name] = function () {
            return this.renderer[name].apply(this.renderer, arguments);
        };
    }

    _initRenderer(host) {
        return this.createRenderer(this, host);
    }

    _internalRefresh() {
        const self = this;

        // validate visiblity
        if (window.getComputedStyle(self.host).display === 'none') {
            return;
        }

        if (!self.renderer) {
            self.host.innerHTML = '';
            self._initRenderer(self.host);
        }

        const renderer = self.renderer;
        if (!renderer)
            return;

        const rect = renderer.getRect();

        self._render({ x: 1, y: 1, width: rect.width, height: rect.height });
    }

    _render(rect) {
        this._plotRect = rect;
    }

    // Public API
    refresh() {
        this._internalRefresh();
    }

    getSize() {
        const rect = this._plotRect;
        return { width: rect.width, height: rect.height };
    }

    toGreyScale(color) {
        if (color.indexOf('#') === -1)
            return color;

        const rgb = this.cssToRgb(color);
        rgb[0] = rgb[1] = rgb[2] = Math.round(0.3 * rgb[0] + 0.59 * rgb[1] + 0.11 * rgb[2]);
        const hex = this.rgbToHex(rgb[0], rgb[1], rgb[2]);
        return '#' + hex[0] + hex[1] + hex[2];
    }

    decToHex(dec) {
        return dec.toString(16);
    }

    hexToDec(hex) {
        return parseInt(hex, 16);
    }

    rgbToHex(r, g, b) {
        return [this.decToHex(r), this.decToHex(g), this.decToHex(b)];
    }

    hexToRgb(h, e, x) {
        return [this.hexToDec(h), this.hexToDec(e), this.hexToDec(x)];
    }

    cssToRgb(color) {
        if (color.indexOf('rgb') <= -1) {
            return this.hexToRgb(color.substring(1, 3), color.substring(3, 5), color.substring(5, 7));
        }
        return color.substring(4, color.length - 1).split(',');
    }

    hslToRgb(hsl) {
        let r, g, b;
        const h = parseFloat(hsl[0]);
        const s = parseFloat(hsl[1]);
        const l = parseFloat(hsl[2]);

        if (s === 0) {
            r = g = b = l;
        }
        else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = this.hueToRgb(p, q, h + 1 / 3);
            g = this.hueToRgb(p, q, h);
            b = this.hueToRgb(p, q, h - 1 / 3);
        }
        return [r * 255, g * 255, b * 255];
    }

    hueToRgb(p, q, t) {
        if (t < 0)
            t += 1;
        if (t > 1)
            t -= 1;

        if (t < 1 / 6)
            return p + (q - p) * 6 * t;
        else if (t < 1 / 2)
            return q;
        else if (t < 2 / 3)
            return p + (q - p) * (2 / 3 - t) * 6;

        return p;

    }

    rgbToHsl(rgb) {
        const r = parseFloat(rgb[0]) / 255;
        const g = parseFloat(rgb[1]) / 255;
        const b = parseFloat(rgb[2]) / 255;

        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0;
        }
        else {
            const diff = max - min;
            s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);
            switch (max) {
                case r: h = (g - b) / diff + (g < b ? 6 : 0); break;
                case g: h = (b - r) / diff + 2; break;
                case b: h = (r - g) / diff + 4; break;
            }
            h /= 6;
        }

        return [h, s, l];
    }

    swap(x, y) {
        const tmp = x;
        x = y;
        y = tmp;
    }

    getNum(arr) {
        if (arr.constructor !== Array) {
            if (isNaN(arr))
                return 0;
        }
        else {
            for (let i = 0; i < arr.length; i++)
                if (!isNaN(arr[i]))
                    return arr[i];
        }

        return 0;
    }

    _ptdist(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }

    _ptRotate(x, y, cx, cy, angle) {
        const radius = Math.sqrt(Math.pow(Math.abs(x - cx), 2) + Math.pow(Math.abs(y - cy), 2));
        const currAngle = Math.asin((x - cx) / radius);
        const newAngle = currAngle + angle;

        x = cx + Math.cos(newAngle) * radius;
        y = cy + Math.sin(newAngle) * radius;

        return { x: x, y: y };
    }

    log(val, base) {
        return Math.log(val) / (base ? Math.log(base) : 1);
    }

    _mod(a, b) {
        const min = Math.abs(a > b ? b : a);
        let scale = 1;
        if (min !== 0) {
            while (min * scale < 100)
                scale *= 10;
        }

        a = a * scale;
        b = b * scale;

        return (a % b) / scale;
    }

    ptrnd(val) {
        if (Math.abs(Math.round(val) - val) === 0.5)
            return val;

        let rnd = Math.round(val);
        if (rnd < val)
            rnd = rnd - 1;

        return rnd + 0.5;
    }

    createRenderer(widgetInstance, host) {
        const self = widgetInstance;

        let renderer = self.renderer = null;

        if (document.createElementNS) {
            renderer = new JQX.Utilities.SvgRenderer;
            renderer.init(host);
        }

        self.renderer = renderer;

        return renderer;
    }

    getByPriority(arr) {
        let value = undefined;
        for (let i = 0; i < arr.length && value === undefined; i++) {
            if (value === undefined && arr[i] !== undefined)
                value = arr[i];
        }

        return value;
    }

    get(array, index, key) {
        return key !== undefined ? array[index][key] : array[index];
    }

    min(array, key) {
        let min = NaN;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);

            if (isNaN(min) || val < min)
                min = val;
        }

        return min;
    }

    max(array, key) {
        let max = NaN;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);

            if (isNaN(max) || val > max)
                max = val;
        }

        return max;
    }

    sum(array, key) {
        let sum = 0;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);
            if (!isNaN(val))
                sum += val;
        }

        return sum;
    }

    count(array, key) {
        let count = 0;
        for (let i = 0; i < array.length; i++) {
            const val = this.get(array, i, key);
            if (!isNaN(val))
                count++;
        }

        return count;
    }

    avg(array, key) {
        return this.sum(array, key) / Math.max(1, this.count(array, key));
    }

    filter(array, fn) {
        if (!fn)
            return array;

        const out = [];
        for (let i = 0; i < array.length; i++)
            if (fn(array[i]))
                out.push(array[i]);

        return out;
    }

    scale(val, range, scale_range, params) {
        if (isNaN(val))
            return NaN;

        if (val < Math.min(range.min, range.max) || val > Math.max(range.min, range.max)) {
            if (!params || params['ignore_range'] !== true)
                return NaN;
        }

        let outVal = NaN;

        let percent = 1;
        if (range.type === undefined || range.type !== 'logarithmic') {
            let denom = Math.abs(range.max - range.min);
            if (!denom)
                denom = 1;
            percent = Math.abs(val - Math.min(range.min, range.max)) / denom;
        }
        else if (range.type === 'logarithmic') {
            let logBase = range.base;
            if (isNaN(logBase))
                logBase = 10;

            let min = Math.min(range.min, range.max);
            if (min <= 0)
                min = 1;

            let max = Math.max(range.min, range.max);
            if (max <= 0)
                max = 1;

            const maxPow = this.log(max, logBase);
            max = Math.pow(logBase, maxPow);

            const minPow = this.log(min, logBase);
            min = Math.pow(logBase, minPow);

            const valPow = this.log(val, logBase);

            percent = Math.abs(valPow - minPow) / (maxPow - minPow);
        }

        if (scale_range.type === 'logarithmic') {
            let logBase = scale_range.base;
            if (isNaN(logBase))
                logBase = 10;

            const maxPow = this.log(scale_range.max, logBase),
                minPow = this.log(scale_range.min, logBase);

            if (scale_range.flip)
                percent = 1 - percent;

            const valPow = Math.min(minPow, maxPow) + percent * Math.abs(maxPow - minPow);
            outVal = Math.pow(logBase, valPow);
        }
        else {
            outVal = Math.min(scale_range.min, scale_range.max) + percent * Math.abs(scale_range.max - scale_range.min);

            if (scale_range.flip)
                outVal = Math.max(scale_range.min, scale_range.max) - outVal + scale_range.min;
        }

        return outVal;
    }

    axis(min, max, preferedCount) {
        if (preferedCount <= 1)
            return [max, min];

        if (isNaN(preferedCount) || preferedCount < 2)
            preferedCount = 2;

        let decimalPlaces = 0;
        while (Math.round(min) !== min && Math.round(max) !== max && decimalPlaces < 10) {
            min *= 10;
            max *= 10;
            decimalPlaces++;
        }

        let preferedIntSize = (max - min) / preferedCount;
        while (decimalPlaces < 10 && Math.round(preferedIntSize) !== preferedIntSize) {
            min *= 10;
            max *= 10;
            preferedIntSize *= 10;
            decimalPlaces++;
        }

        const scale = [1, 2, 5];

        let i = 0,
            intSizeNext;

        // eslint-disable-next-line
        while (true) {
            let idx = i % scale.length;
            let pow = Math.floor(i / scale.length);
            let intSizeCurr = Math.pow(10, pow) * scale[idx];

            idx = (i + 1) % scale.length;
            pow = Math.floor((i + 1) / scale.length);
            intSizeNext = Math.pow(10, pow) * scale[idx];

            if (preferedIntSize >= intSizeCurr && preferedIntSize < intSizeNext)
                break;

            i++;
        }

        const intSizeSelected = intSizeNext;

        const out = [];
        let curr = this.renderer._rnd(min, intSizeSelected, false);
        const denominator = decimalPlaces <= 0 ? 1 : Math.pow(10, decimalPlaces);
        while (curr < max + intSizeSelected) {
            out.push(curr / denominator);
            curr += intSizeSelected;
        }

        return out;
    }
});

// SvgRenderer class
JQX.Utilities.Assign('SvgRenderer', class SvgRenderer {
    constructor() {
        const that = this;
        that._svgns = 'http://www.w3.org/2000/svg';
        that._openGroups = [];
        that._clipId = 0;
        that._gradients = {};

        that._toRadiansCoefficient = Math.PI * 2 / 360;
    }

    init(host) {
        const container = document.createElement('div');

        container.className = 'drawContainer';
        container.onselectstart = function () {
            return false;
        }

        host.appendChild(container);

        this.host = host;
        this.container = container;

        try {
            const svg = document.createElementNS(this._svgns, 'svg');
            svg.setAttribute('version', '1.1');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('overflow', 'hidden');
            container.appendChild(svg);
            this.canvas = svg;
        }
        catch (e) {
            return false;
        }

        this._id = new Date().getTime();
        this.clear();

        return true;
    }

    getType() {
        return 'SVG';
    }

    refresh() {
    }

    _rup(n) {
        let nr = Math.round(n);
        if (n > nr)
            nr++;

        return nr;
    }

    getRect() {
        return { x: 0, y: 0, width: Math.max(this._rup(this.host.offsetWidth) - 1, 0), height: Math.max(this._rup(this.host.offsetHeight) - 1, 0) };
    }

    getContainer() {
        return this.container;
    }

    clear() {
        while (this.canvas.childNodes.length > 0) {
            this.removeElement(this.canvas.firstElementChild);
        }

        this._defaultParent = undefined;
        this._defs = document.createElementNS(this._svgns, 'defs');
        this._gradients = {};
        this.canvas.appendChild(this._defs);
    }

    removeElement(element) {
        if (undefined === element)
            return;

        try {
            while (element.firstChild) {
                this.removeElement(element.firstChild);
            }

            if (element.parentNode)
                element.parentNode.removeChild(element);
            else
                this.canvas.removeChild(element);
        }
        catch (error) {
            //
        }
    }

    beginGroup() {
        const parent = this._activeParent();
        const g = document.createElementNS(this._svgns, 'g');
        parent.appendChild(g);
        this._openGroups.push(g);

        return g;
    }

    endGroup() {
        if (this._openGroups.length === 0)
            return;

        this._openGroups.pop();
    }

    _activeParent() {
        return this._openGroups.length === 0 ? this.canvas : this._openGroups[this._openGroups.length - 1];
    }

    createClipRect(rect) {
        const c = document.createElementNS(this._svgns, 'clipPath');
        const r = document.createElementNS(this._svgns, 'rect');
        this.attr(r, { x: rect.x, y: rect.y, width: rect.width, height: rect.height, fill: 'none' });

        this._clipId = this._clipId || 0;
        c.id = 'cl' + this._id + '_' + (++this._clipId).toString();
        c.appendChild(r);

        this._defs.appendChild(c);

        return c;
    }

    getWindowHref() {
        // Get modified href. This is needed to handle cases where the page uses <base> tags.

        let href = window.location.href;
        if (!href)
            return href;

        href = href.replace(/([\('\)])/g, '\\$1'); // escape brackets & quotes (Chrome)
        href = href.replace(/#.*$/, ''); // remove bookmark links

        return href;
    }

    setClip(elem, clip) {
        const url = 'url(' + this.getWindowHref() + '#' + clip.id + ')';
        return this.attr(elem, { 'clip-path': url });
    }

    shape(name, params) {
        const s = document.createElementNS(this._svgns, name);
        if (!s)
            return undefined;

        for (let param in params)
            s.setAttribute(param, params[param]);

        this._activeParent().appendChild(s);

        return s;
    }

    _getTextParts(text, angle, params) {
        const textPartsInfo = { width: 0, height: 0, parts: [] };
        if (undefined === text)
            return textPartsInfo;

        const coeff = 0.6;
        const textParts = text.toString().split('<br>');

        const parent = this._activeParent();
        const txt = document.createElementNS(this._svgns, 'text');
        this.attr(txt, params);

        for (let i = 0; i < textParts.length; i++) {
            const textPart = textParts[i];

            const txtNode = txt.ownerDocument.createTextNode(textPart);
            txt.appendChild(txtNode);

            parent.appendChild(txt);
            let bbox;
            try {
                bbox = txt.getBBox();
            }
            catch (e) {
                //
            }

            const tw = this._rup(bbox.width);
            const th = this._rup(bbox.height * coeff);

            txt.removeChild(txtNode);

            textPartsInfo.width = Math.max(textPartsInfo.width, tw);
            textPartsInfo.height += th + (i > 0 ? 4 : 0);
            textPartsInfo.parts.push({ width: tw, height: th, text: textPart });
        }
        parent.removeChild(txt);

        return textPartsInfo;
    }

    measureText(text, angle, params, includeTextPartsInfo) {
        const textPartsInfo = this._getTextParts(text, angle, params);
        const tw = textPartsInfo.width;
        let th = textPartsInfo.height;

        if (false === includeTextPartsInfo)
            th /= 0.6;

        let retVal = {};

        if (isNaN(angle))
            angle = 0;

        if (angle === 0) {
            retVal = { width: this._rup(tw), height: this._rup(th) };
        }
        else {
            const rads = angle * Math.PI * 2 / 360;
            const sn = Math.abs(Math.sin(rads));
            const cs = Math.abs(Math.cos(rads));
            const bh = Math.abs(tw * sn + th * cs);
            const bw = Math.abs(tw * cs + th * sn);

            retVal = { width: this._rup(bw), height: this._rup(bh) };
        }

        if (includeTextPartsInfo)
            retVal.textPartsInfo = textPartsInfo;

        return retVal;
    }

    alignTextInRect(x, y, width, height, textWidth, textHeight, halign, valign, angle, rotateAround) {
        const rads = angle * Math.PI * 2 / 360;
        const sn = Math.sin(rads);
        const cs = Math.cos(rads);

        const h2 = textWidth * sn;
        const w2 = textWidth * cs;

        if (halign === 'center' || halign === '' || halign === 'undefined')
            x = x + width / 2;
        else if (halign === 'right')
            x = x + width;

        if (valign === 'center' || valign === 'middle' || valign === '' || valign === 'undefined')
            y = y + height / 2;
        else if (valign === 'bottom')
            y += height - textHeight / 2;
        else if (valign === 'top')
            y += textHeight / 2;

        rotateAround = rotateAround || '';

        let adjustY = 'middle';
        if (rotateAround.indexOf('top') !== -1)
            adjustY = 'top';
        else if (rotateAround.indexOf('bottom') !== -1)
            adjustY = 'bottom';

        let adjustX = 'center';
        if (rotateAround.indexOf('left') !== -1)
            adjustX = 'left';
        else if (rotateAround.indexOf('right') !== -1)
            adjustX = 'right';

        if (adjustX === 'center') {
            x -= w2 / 2;
            y -= h2 / 2;
        }
        else if (adjustX === 'right') {
            x -= w2;
            y -= h2;
        }

        if (adjustY === 'top') {
            x -= textHeight * sn;
            y += textHeight * cs;
        }
        else if (adjustY === 'middle') {
            x -= textHeight * sn / 2;
            y += textHeight * cs / 2;
        }

        x = this._rup(x);
        y = this._rup(y);

        return { x: x, y: y };
    }

    text(text, x, y, width, height, angle, params, clip, halign, valign, rotateAround) {
        const sz = this.measureText(text, angle, params, true, this);
        const textPartsInfo = sz.textPartsInfo;
        const textParts = textPartsInfo.parts;
        let gClip;
        if (!halign)
            halign = 'center';
        if (!valign)
            valign = 'center';

        if (textParts.length > 1 || clip)
            gClip = this.beginGroup();

        if (clip) {
            const crect = this.createClipRect({ x: this._rup(x) - 1, y: this._rup(y) - 1, width: this._rup(width) + 2, height: this._rup(height) + 2 });
            this.setClip(gClip, crect);
        }

        //this.rect(x, y, width, height, {fill: 'yellow', stroke: 'red'});

        let parent = this._activeParent();

        let tw = 0, th = 0;

        tw = textPartsInfo.width;
        th = textPartsInfo.height;

        if (isNaN(width) || width <= 0)
            width = tw;
        if (isNaN(height) || height <= 0)
            height = th;

        const w = width || 0;
        const h = height || 0;

        let yOffset = 0;

        if (!angle || angle === 0) {
            y += th;

            if (valign === 'center' || valign === 'middle')
                y += (h - th) / 2;
            else if (valign === 'bottom')
                y += h - th;

            if (!width)
                width = tw;

            if (!height)
                height = th;

            parent = this._activeParent();
            let txt;
            for (let i = textParts.length - 1; i >= 0; i--) {
                txt = document.createElementNS(this._svgns, 'text');
                this.attr(txt, params);
                this.attr(txt, { cursor: 'default' });

                const txtNode = txt.ownerDocument.createTextNode(textParts[i].text);
                txt.appendChild(txtNode);

                let xOffset = x;
                const wPart = textParts[i].width;
                const hPart = textParts[i].height;

                if (halign === 'center')
                    xOffset += (w - wPart) / 2;
                else if (halign === 'right')
                    xOffset += (w - wPart);

                this.attr(txt, { x: this._rup(xOffset), y: this._rup(y + yOffset), width: this._rup(wPart), height: this._rup(hPart) });
                parent.appendChild(txt);

                yOffset -= textParts[i].height + 4;
            }

            if (gClip) {
                this.endGroup();
                return gClip;
            }

            return txt;
        }

        const point = this.alignTextInRect(x, y, width, height, tw, th, halign, valign, angle, rotateAround);
        x = point.x;
        y = point.y;

        const gTranslate = this.shape('g', { transform: 'translate(' + x + ',' + y + ')' });
        const gRotate = this.shape('g', { transform: 'rotate(' + angle + ')' });

        gTranslate.appendChild(gRotate);

        // add the text blocks
        yOffset = 0;

        for (let i = textParts.length - 1; i >= 0; i--) {
            const tx = document.createElementNS(this._svgns, 'text');
            this.attr(tx, params);
            this.attr(tx, { cursor: 'default' });

            const txtNode = tx.ownerDocument.createTextNode(textParts[i].text);
            tx.appendChild(txtNode);

            let xOffset = 0;
            const wPart = textParts[i].width;
            const hPart = textParts[i].height;

            if (halign === 'center')
                xOffset += (textPartsInfo.width - wPart) / 2;
            else if (halign === 'right')
                xOffset += (textPartsInfo.width - wPart);

            this.attr(tx, { x: this._rup(xOffset), y: this._rup(yOffset), width: this._rup(wPart), height: this._rup(hPart) });
            gRotate.appendChild(tx);

            yOffset -= hPart + 4;
        }

        parent.appendChild(gTranslate);

        if (gClip)
            this.endGroup();

        return gTranslate;
    }

    line(x1, y1, x2, y2, params) {
        const line = this.shape('line', { x1: x1, y1: y1, x2: x2, y2: y2 });
        this.attr(line, params);
        return line;
    }

    path(points, params) {
        const s = this.shape('path');
        s.setAttribute('d', points);
        if (params) {
            this.attr(s, params);
        }
        return s;
    }

    _rnd(num, unit, toGreater, fast) {
        if (isNaN(num))
            return num;

        if (undefined === fast)
            fast = true;

        let a = num - ((fast === true) ? num % unit : this._mod(num, unit));
        if (num === a)
            return a;

        if (toGreater) {
            if (num > a)
                a += unit;
        }
        else {
            if (a > num)
                a -= unit;
        }

        return (unit === 1) ? Math.round(a) : a;
    }

    _ptrnd(val) {
        if (!document.createElementNS) {
            if (Math.round(val) === val)
                return val;
            return this._rnd(val, 1, false, true);
        }

        const rnd = this._rnd(val, 0.5, false, true);
        if (Math.abs(rnd - Math.round(rnd)) !== 0.5) {
            return rnd > val ? rnd - 0.5 : rnd + 0.5;
        }
        return rnd;
    }

    rect(x, y, w, h, params) {
        x = this._ptrnd(x);
        y = this._ptrnd(y);
        w = Math.max(1, this._rnd(w, 1, false));
        h = Math.max(1, this._rnd(h, 1, false));
        const s = this.shape('rect', { x: x, y: y, width: w, height: h });
        if (params)
            this.attr(s, params);
        return s;
    }

    circle(x, y, r, params) {
        const s = this.shape('circle', { cx: x, cy: y, r: r });
        if (params)
            this.attr(s, params);
        return s;
    }

    pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset) {
        if (!outerRadius)
            outerRadius = 1;

        const diff = Math.abs(angleFrom - angleTo);
        const lFlag = diff > 180 ? 1 : 0;
        if (diff >= 360) {
            angleTo = angleFrom + 359.99;
        }
        const radFrom = angleFrom * this._toRadiansCoefficient;
        const radTo = angleTo * this._toRadiansCoefficient;

        let x1 = x, x2 = x, y1 = y, y2 = y;

        const isDonut = !isNaN(innerRadius) && innerRadius > 0;

        if (isDonut)
            centerOffset = 0;

        const radFromCos = Math.cos(radFrom),
            radFromSin = Math.sin(radFrom),
            radToCos = Math.cos(radTo),
            radToSin = Math.sin(radTo);

        if (centerOffset + innerRadius > 0) {
            if (centerOffset > 0) {
                const midAngle = diff / 2 + angleFrom;
                const radMid = midAngle * this._toRadiansCoefficient;

                x += centerOffset * Math.cos(radMid);
                y -= centerOffset * Math.sin(radMid);
            }

            if (isDonut) {
                x1 = x + innerRadius * radFromCos;
                y1 = y - innerRadius * radFromSin;
                x2 = x + innerRadius * radToCos;
                y2 = y - innerRadius * radToSin;
            }
        }

        const x3 = x + outerRadius * radFromCos;
        const x4 = x + outerRadius * radToCos;
        const y3 = y - outerRadius * radFromSin;
        const y4 = y - outerRadius * radToSin;

        let path = '';

        const isPartialCircle = (Math.abs(Math.abs(angleTo - angleFrom) - 360) > 0.02);

        if (isDonut) {
            path = 'M ' + x2 + ',' + y2;
            path += ' a' + innerRadius + ',' + innerRadius;
            path += ' 0 ' + lFlag + ',1 ' + (x1 - x2) + ',' + (y1 - y2);
            if (isPartialCircle)
                path += ' L' + x3 + ',' + y3;
            else
                path += ' M' + x3 + ',' + y3;

            path += ' a' + outerRadius + ',' + outerRadius;
            path += ' 0 ' + lFlag + ',0 ' + (x4 - x3) + ',' + (y4 - y3);

            if (isPartialCircle)
                path += ' Z';
        }
        else {
            path = 'M ' + x4 + ',' + y4;
            path += ' a' + outerRadius + ',' + outerRadius;
            path += ' 0 ' + lFlag + ',1 ' + (x3 - x4) + ',' + (y3 - y4);

            if (isPartialCircle) {
                path += ' L' + x + ',' + y;
                path += ' Z';
            }
        }

        return path;
    }

    pieslice(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset, params) {
        const pathCmd = this.pieSlicePath(x, y, innerRadius, outerRadius, angleFrom, angleTo, centerOffset);

        const s = this.shape('path');
        s.setAttribute('d', pathCmd);

        if (params)
            this.attr(s, params);

        return s;
    }

    attr(element, params) {
        if (!element || !params)
            return;

        for (let param in params) {
            if (param === 'textContent')
                element.textContent = params[param];
            else {
                element.setAttribute(param, params[param]);
            }
        }
    }

    removeAttr(element, params) {
        if (!element || !params)
            return;

        for (let param in params) {
            if (param === 'textContent')
                element.textContent = '';
            else {
                element.removeAttribute(params[param]);
            }
        }
    }

    getAttr(element, key) {
        return element['getAttribute'](key);
    }

    adjustColor(color, adj) {
        if (typeof (color) !== 'string')
            return '#000000';

        if (color.indexOf('#') === -1)
            return color;

        let rgb = this.cssToRgb(color);
        const hsl = this.rgbToHsl(rgb);
        hsl[2] = Math.min(1, hsl[2] * adj);
        hsl[1] = Math.min(1, hsl[1] * adj * 1.1);
        rgb = this.hslToRgb(hsl);

        color = '#';
        for (let i = 0; i < 3; i++) {
            let c = Math.round(rgb[i]);
            c = this.decToHex(c);
            if (c.toString().length === 1)
                color += '0';

            color += c;
        }

        return color.toUpperCase();
    }

    _toLinearGradient(color, isVertical, stops) {
        const id = 'grd' + this._id + color.replace('#', '') + (isVertical ? 'v' : 'h');
        const url = 'url(' + this.getWindowHref() + '#' + id + ')';
        if (this._gradients[url])
            return url;

        const gr = document.createElementNS(this._svgns, 'linearGradient');
        this.attr(gr, { x1: '0%', y1: '0%', x2: isVertical ? '0%' : '100%', y2: isVertical ? '100%' : '0%', id: id });

        for (let i = 0; i < stops.length; i++) {
            const stop = stops[i];
            const s = document.createElementNS(this._svgns, 'stop');
            const st = 'stop-color:' + this.adjustColor(color, stop[1]);
            this.attr(s, { offset: stop[0] + '%', style: st });
            gr.appendChild(s);
        }

        this._defs.appendChild(gr);
        this._gradients[url] = true;

        return url;
    }

    _toRadialGradient(color, stops, coords) {
        const id = 'grd' + this._id + color.replace('#', '') + 'r' + (coords !== undefined ? coords.key : '');

        const url = 'url(' + this.getWindowHref() + '#' + id + ')';
        if (this._gradients[url])
            return url;

        const gr = document.createElementNS(this._svgns, 'radialGradient');
        if (coords === undefined)
            this.attr(gr, { cx: '50%', cy: '50%', r: '100%', fx: '50%', fy: '50%', id: id });
        else
            this.attr(gr, { cx: coords.x, cy: coords.y, r: coords.outerRadius, id: id, gradientUnits: 'userSpaceOnUse' });

        for (let i = 0; i < stops.length; i++) {
            const stop = stops[i];
            const s = document.createElementNS(this._svgns, 'stop');
            const st = 'stop-color:' + this.adjustColor(color, stop[1]);
            this.attr(s, { offset: stop[0] + '%', style: st });
            gr.appendChild(s);
        }

        this._defs.appendChild(gr);
        this._gradients[url] = true;

        return url;
    }
});